{"name":"Prevail","tagline":"A data abstraction library","body":"# Prevail\r\n\r\nPrevail is an abstraction layer for your application data.\r\n\r\nIt is not an ORM framework, a persistence layer, a networking library or anything complicated.\r\n\r\nIt simply allows your applications to abstract away the sources of its data. By using Prevail, access to your data becomes asynchronous and event driven. Importantly, the sources of data are decoupled from the logic of your application.\r\n\r\n##Latest Release:\r\n\r\nBoreas 0.2.4 - [Javadoc](javadoc/0.2.4/base/index.html)\r\n\r\n### Gradle Usage\r\n\r\nPrevail is published on Sonatype, and is available from Maven Central.  \r\n\r\nImport the java library with:\r\n\r\n`dependencies {\r\n    compile 'ninja.ugly:prevail:0.2.4'\r\n}`\r\n\r\nAlternatively, Android developers can import the Android library directly with just\r\n\r\n`dependencies {\r\n    compile 'ninja.ugly:android-prevail:0.2.4'\r\n}`\r\n\r\n##Motivations:\r\n\r\nPrevail is motivated by the following points:\r\n\r\n* The majority of code in an application cares little about the source of the data on which it operates.\r\nData should be event driven. When stuff changes, you want to know about it. It's not enough to just query an object. We want to know when that object becomes invalid.\r\n* Sources of data should be easily changed, without disrupting lots of code. It should be easy to swap a network resource for a hashtable during testing. Sure, that could be achieved by setting up fake test objects, but why bother when it should be easy to swap in new data sources quickly in the first place. Such decoupled code is easier to change in the future too.\r\n* It should be easy to perform data operations on multiple data sources at once. A local cache query might return quickly, whilst a network query may take longer. However, it should be possible for client code to be completely unaware that there are multiple sources of data. It should be possible for a client merely to handle the data as it arrives.\r\n\r\nIn particular, on Android:\r\n\r\n* Many people use ContentProviders for data simply because they give easy access to a certain type of data abstraction, however this can easily contaminate your application with Cursors, Uris, ContentObservers and CursorLoaders. It's frustrating to have code that depends on these classes, when they should really never penetrate into the application's domain. It's much nicer to have all the good stuff, like asynchronous loading and notification of change, within your own classes in your own domain.\r\n* What happens when you realise that all the stuff you've been persisting to SharedPreferences needs to be in a database so that you can access it with a richer query language? In that case, client code shouldn't have to change.  Want to expirement with a NoSQL database, no problem... client code will not care.\r\n\r\n##Concepts:\r\n\r\nThe following classes are defined in Prevail:\r\n\r\n1. [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html).  This is the interface to a segment of your data.  \r\n  * You implement this to provide data for your application.\r\n  * It implements the relevant CRUD operations on your data, be it a network resource, a database, a file, etc.  \r\n  * All operations complete synchronously.  That is, they execute on the calling thread and block until completion.  The operations return results directly as method return values.\r\n  * It is defined with two generic types, one type is the key by which your data will be accessed, the other type is the value that your [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) returns.  On Android, if you really love ContentProviders, say, then the key could be a Uri and the value could be a Cursor, but these types are completely general and you are free to define the key and value types however you like.  For example, the value could be any type in your domain.  The key could be as simple as an int, or a String containing a simple query language (eg, \"all\", \"one with id 3\"), or some much richer type that defines a query perhaps containing filters, ranges or limits.\r\n * If your data-model has multiple value types, a [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) is required for each.\r\n * If you want to query the same data with different key types, a [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) is required for each key type. \r\n\r\n2. [DataModel](javadoc/0.2.4/base/ninja/ugly/prevail/datamodel/DataModel.html). This class is a container for registered [Chunks](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html).\r\n * Each [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) is registered to a [DataModel](javadoc/0.2.4/base/ninja/ugly/prevail/datamodel/DataModel.html), optionally by name.\r\n * Operations are forwarded to a [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) by name.  Optionally, if no name is provided then the operations are forwarded to all registered [Chunks](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) of the appropriate types.\r\n * All operations complete asynchronously.  That is, they do not block the calling thread.  They return their results in events via an [EventDispatcher](javadoc/0.2.4/base/ninja/ugly/prevail/event/dispatcher/EventDispatcher.html) (See below).\r\n * All operations return a Future to their result, just in case you do want to block the calling thread.  This is often useful when the calling thread is already in the background and it's acceptable to block until the operation completes.\r\n\r\n3. [EventDispatcher](javadoc/0.2.4/base/ninja/ugly/prevail/event/dispatcher/EventDispatcher.html).  This is the interface used to return the results of [DataModel](javadoc/0.2.4/base/ninja/ugly/prevail/datamodel/DataModel.html) operations asynchronously.  \r\n  * You implement this to define whatever event distribution mechanism you like.  On Android, this could use ContentObservers, if you like Cursors and Uris.  This could send Intents to BroadcastReceivers, which might be useful if your data is accessed from outside of your application.  Most simply, it could just use an event bus, such as that provided by Google's guava library to send POJOs.\r\n  * Whilst Prevail needs an implementation of [EventDispatcher](javadoc/0.2.4/base/ninja/ugly/prevail/event/dispatcher/EventDispatcher.html) to distribute the results of [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) operations, the receipt of these results is completely independent of Prevail.  If you use Intents, the register BroadcastRecievers as normal.  If you use an event bus, then subscribe to the events as normal.\r\n  * All event dispatching should complete asynchronously.\r\n\r\n4.  [EventFactory](javadoc/0.2.4/base/ninja/ugly/prevail/event/factory/EventFactory.html).  This is the interface used to produce the required events for distrubution with the [EventDispatcher](javadoc/0.2.4/base/ninja/ugly/prevail/event/dispatcher/EventDispatcher.html).\r\n  * You define events for one or more of the start, end, progress and error from [Chunk](javadoc/0.2.4/base/ninja/ugly/prevail/chunk/Chunk.html) operations.\r\n  * These can be set globally on the Chunk, one for each CRUD operation, to distribute events from any such operation.  Alternatively, an [EventFactory](javadoc/0.2.4/base/ninja/ugly/prevail/event/factory/EventFactory.html) can be passed into each [DataModel](javadoc/0.2.4/base/ninja/ugly/prevail/datamodel/DataModel.html) operation in order to generate one off, bespoke, events for that operation.\r\n\r\n##Examples:\r\n\r\nThere are two example applications within the sources:\r\n\r\n1.  A Java application manages a list of 'To Do' items.  The items are only persisted in memory, but the client code doesn't care, it merely invokes changes and responds to change events.\r\n2.  An Android app that implements a little 'To Do' list of items.  \r\n  * The items are persisted to an SQLite3 database but, again, the client code does not care about this.\r\n  * There are controls on the UI for managing the list of items, which simply invoke change and respond to change events.  \r\n  * The items are displayed in a ListView that can be managed with or without a Loader.\r\n\r\n##Roadmap:\r\n\r\n* Improved main library javadoc.\r\n* Android library javadoc.\r\n\r\n##License:\r\n\r\nPrevail is distributed under the MIT License.  Please see the license document within the source repository.","google":"UA-52573683-1","note":"Don't delete this file! It's used internally to help with page regeneration."}