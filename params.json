{"name":"Prevail","tagline":"A data abstraction library","body":"# Prevail\r\n\r\nPrevail is an abstraction layer for your application data.\r\n\r\nIt is not an ORM framework, a persistence layer, a networking library or anything complicated.\r\n\r\nIt simply allows your applications to abstract away the sources of its data. By using Prevail, access to your data becomes asynchronous and event driven. Importantly, the sources of data are decoupled from the logic of your application.\r\n\r\n##Latest Release:\r\n\r\nBoreas 0.2.3 - [Javadoc](javadoc/0.2.3/base/index.html)\r\n\r\n### Gradle Usage\r\n\r\nPrevail is published on Sonatype, and is available from Maven Central.  \r\n\r\nImport the java library with:\r\n\r\n`dependencies {\r\n    compile 'ninja.ugly:prevail:0.2.3'\r\n}`\r\n\r\nAlternatively, Android developers can import the Android library directly with just\r\n\r\n`dependencies {\r\n    compile 'ninja.ugly:android-prevail:0.2.3'\r\n}`\r\n\r\n##Motivations:\r\n\r\nPrevail is motivated by the following points:\r\n\r\n* The majority of code in an application cares little about the source of the data on which it operates.\r\nData should be event driven. When stuff changes, you want to know about it. It's not enough to just query an object. We want to know when that object becomes invalid.\r\n* Sources of data should be easily changed, without disrupting lots of code. It should be easy to swap a network resource for a hashtable during testing. Sure, that could be achieved by setting up fake test objects, but why bother when it should be easy to swap in new data sources quickly in the first place. Such decoupled code is easier to change in the future too.\r\n* It should be easy to perform data operations on multiple data sources at once. A local cache query might return quickly, whilst a network query may take longer. However, it should be possible for client code to be completely unaware that there are multiple sources of data. It should be possible for a client merely to handle the data as it arrives.\r\n\r\nIn particular, on Android:\r\n\r\n* Many people use ContentProviders for data simply because they give easy access to useful asynchronous functionality however. This can easily contaminate your application with Cursors, Uris, ContentObservers and CursorLoaders. It's frustrating to have code that depends on these classes, when they should really never penetrate into the application's domain. It's much nicer to have all the good stuff, like asynchronous loading and notification of change, within your own classes in your own domain.\r\n* What happens when you realise that all the stuff you've been persisting to SharedPreferences needs to be in a database so that you can access it with a richer query language? In that case, client code shouldn't have to change.  Want to expirement with a NoSQL database, no problem... client code will not care.\r\n\r\n##Examples:\r\n\r\nThere are two example applications within the sources:\r\n\r\n1.  A Java application manages a list of 'To Do' items.  The items are only persisted in memory, but the client code doesn't care, it merely invokes changes and responds to change events.\r\n2.  An Android app that implements a little 'To Do' list of items.  \r\n  * The items are persisted to an SQLite3 database but, again, the client code does not care about this.\r\n  * There are controls on the UI for managing the list of items, which simply invoke change and respond to change events.  \r\n  * The items are displayed in a ListView that can be managed with or without a Loader.\r\n\r\n##Roadmap:\r\n\r\n* Improved main library javadoc.\r\n* Android library javadoc.\r\n\r\n##License:\r\n\r\nPrevail is distributed under the MIT License.  Please see the license document within the source repository.","google":"UA-52573683-1","note":"Don't delete this file! It's used internally to help with page regeneration."}